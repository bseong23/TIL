# Class

# 객체지향 프로그래밍

### 절차 지향 프로그래밍
- 프로그램을 '데이터'와 '절차'로 구성하는 방식의 프로그래밍 패러다임

### 절차 지향 프로그래밍 특징
- '데이터'와 해당 데이터를 처리하는 '함수(절차)'가 분리되어 있으며, 함수 호출의 흐름이 중요
- 코드의 순차적인 흐름과 함수 호출에 의해 프로그램이 진행
- 실제로 진행되는 내용이 무엇이 무엇인가가 중요
  

### 객체 지향 프로그래밍 `Object Oriented Programming`

- 데이터와 해당 데이터를 조작하는 메서드를 하나의 객체로 묶어 관리하는 방식의 프로그래밍 패러다임

#### 절차지향 vs 객체지향
- 절차 지향
  - 데이터와 해당 데이터를 처리하는 함수(절차)가 분리
  - 함수 호출의 흐름이 중요
- 객체 지향
  - 데이터와 해당 데이터를 처리하는 메서드(메시지)를 하나의 객체(클래스)로 묶음
  - 객체 간 상호작용과 메시지 전달이 중요


### 객체
#### 클래스 `Class`
- 파이썬에서 타입을 표현하는 방법
- 객체를 생성하기 위한 설계도
- 데이터와 기능을 함께 묶는 방법을 제공

#### 객체 `Object`
- 클래스에서 정의한 것을 토대로 메모리에 할당된 것
- '속성'과 '행동'으로 구성된 모든 것

#### 클래스와 객체
- 클래스로 만든 객체를 인스턴스 라고 부름
- 변수 name의 타입은 str 클래스다.
- 변수 name은 str 클래스의 인스턴스이다.
- 우리가 사용해왔던 데이터 타입은 사실 모두 클래스였다.
```py
  name = 'Alice'

  print(type(name))  # <class 'str'>
```


#### 객체의 특징
- 타입(type) : 어떤 연산자(operator)와 조작(method)이 가능한가?
- 속성(attribute) : 어떤 상태(데이터)를 가지는가?
- 조작법(method) : 어떤 행위(함수)를 할 수 있는가?

### 클래스
- 파이썬에서 타입을 표현하는 방법
- 객체를 생성하기 위한 설계도
- 데이터와 기능을 함께 묶는 방법을 제공
- 클래스 이름은 파스칼 케이스(Pascal Case)

### 클래스 구성요소
1. 생성자 함수
    - 객체를 생성할 때 자동으로 호출되는 특별한 메서드
    - `__init__`이라는 이름의 메서드로 정의되며, 객체의 초기화를 담당
    - 생성자 함수를 통해 인스턴스를 생성하고 필요한 초기값을 설정
    - self 매개변수 필수
    - __ 붙은 애들은 매직메서드 자동호출
2. 인스턴스 변수
    - 인스턴스(객체)마다 별도로 유지되는 변수
    - 인스턴스마다 독립적인 값을 가지며, 인스턴스가 생성될 때마다 초기화됨
3. 클래스 변수
    - 클래스 내부에서 선언된 변수
    - 클래스로 생성된 모든 인스턴스들이 공유하는 변수
4. 인스턴스 메서드
    - 각각의 인스턴스에서 호출할 수 있는 메서드
    - 인스턴스 변수에 접근하고 수정하는 등의 작업을 수행

### 인스턴스 변수와 클래스 변수
- 가수가 몇 명인지 확인하고 싶다면?
  - 인스턴스가 생성 될 때마다 클래스 변수가 늘어나도록 설정할 수 있음
    ```py
    class Person:
        count = 0
        
        def __init__(self, name):
            self.name = name
            Person.count += 1
        
        
    person1 = Person('iu')
    person2 = Person('BTS')
        
    print(Person.count)  # 2
    ```

### 클래스 변수와 인스턴스 변수
- 클래스 변수를 변경할 때는 항상 클래스.클래스변수 형식으로 변경


### 인스턴스 메서드
#### 인스턴스 메서드 `instance method`
- 클래스로부터 생성된 각 인스턴스에서 호출할 수 있는 메서드
- 인스턴스의 상태를 조작하거나 동작을 수행
#### 인스턴스 메서드 구조
- 클래스 내부에 정의되는 메서드의 기본
- 반드시 첫 번째 매개변수로 <span style='color:red;'>인스턴스 자신(`self`)</span>을 전달받음
- self는 매개변수 이름일 뿐이며 다른 이름으로 설정 가능 하지만 다른 이름을 사용하지 않을 것을 강력히 권장


    ```py
    class MyClass:

        def instance_method(self, arg1, ...):
            pass
    ```


#### self 동작 원리
- upper 메서드를 사용해 문자열 ‘hello’를 대문자로 변경하기
    ```py
    'hello'.upper()
    ```

- 하지만 실제 파이썬 내부 동작은 다음과 같이 진행됨
    ```py
    str.upper('hello')
    ```

- str 클래스가 upper 메서드를 호출했고, 그 첫번째 인자로 문자열 인스턴스가 들어간 것

- <span style='color:red;'>인스턴스 메서드의 첫번째 매개변수가 반드시 인스턴스 자기 자신인 이유</span>

- `'hello'.upper()` 은 `str.upper('hello')`를 객체 지향 방식의 메서드로 호출하는 표현 (`단축형 호출`)

- ‘hello’라는 문자열 객체가 단순히 어딘가의 함수로 들어가는 인자가 아닌 객체 스스로 메서드를 호출하여 코드를 동작하는 객체 지향적 표현

#### 생성자 메서드 `constructor method`
- 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드
- 인스턴스 변수들의 초기값을 설정

### 클래스 메서드
#### 클래스 메서드 `class method`
- 클래스가 호출하는 메서드
- 클래스 변수를 조작하거나 클래스 레벨의 동작을 수행

#### 클래스 메서드 구조
- `@classmethod` 데코레이터를 사용하여 정의
- 호출 시, 첫번째 인자로 호출하는 클래스(`cls`)가 전달됨
- cls는 매개변수 이름일 뿐이며 다른 이름으로 설정 가능 하지만 다른 이름을 사용하지 않을 것을 강력히 권장

    ```py
    class MyClass:
        
        @classmethod
        def class_method(cls, arg1, ...):
            pass

    ```

    ### 스태틱 메서드
#### 스태틱(정적) 메서드 `static method`
- 클래스와 인스턴스와 상관없이 독립적으로 동작하는 메서드
- 주로 클래스와 관련이 있지만 인스턴스와 상호작용이 필요하지 않은 경우에 사용

#### 스태틱 메서드 구조
- `@staticmethod` 데코레이터를 사용하여 정의
- 호출 시 필수적으로 작성해야 할 매개변수가 없음
- 즉, 객체 상태나 클래스 상태를 수정할 수 없으며 단지 기능(행동)만을 위한 메서드로 사용
- 호출은 Class가 호출한다

    ```py
    class MyClass:
        
        @staticmethod
        def static_method(arg1, ...):
            pass
    ```

### 메서드 정리
#### 메서드 정리
- 인스턴스 메서드
    - 인스턴스의 상태를 변경하거나, 해당 인스턴스의 특정 동작을 수행

- 클래스 메서드
    - 인스턴스의 상태에 의존하지 않는 기능을 정의
    - 클래스 변수를 조작하거나 클래스 레벨의 동작을 수행

- 스태틱 메서드
    - 클래스 및 인스턴스와 관련이 없는 일반적인 기능을 수행

#### 누가 어떤 메서드를 사용해야 할까 
- 클래스가 사용해야 할 것
    - 클래스 메서드
    - 스태틱 메서드

- 인스턴스가 사용해야 할 것
    - 인스턴스 메서드

#### `할 수 있다 != 써도 된다`
- 각자의 메서드는 OOP 패러다임에 따라 명확한 목적에 맞게 설계된 것이기 때문에 클래스와 인스턴스 각각 올바른 메서드만 사용한다. 각자에 맞게 각자 것만 사용하자


### 오늘 문제
```py
class Car:
    # 아래에 코드를 작성하시오.
    wheels = 4
    def __init__(self, engine, driving_system, sound):
        self.engine = engine
        self.driving_system = driving_system
        self.sound = sound
    
    def drive(self):
        print(self.sound)
        return self.engine
    
    def introduce(self):
        print(f'제 차의 엔진은 {self.engine} 방식이고, {self.driving_system} (으)로 동작합니다.')

    @classmethod
    def increase_wheels(cls):
        cls.wheels += 1
        print(f'법이 개정되어 모든 자동차의 필요 바퀴 수가 1증가하였습니다.')
    
    @staticmethod
    def description():
        print('자동차(自動車, 영어: car, automobile)는 엔진에서 만든 동력을 바퀴에 전달하여 지상에서 승객이나 화물을 운반하는 교통 수단이다.')


car1 = Car('gasoline', '후륜구동', '부릉부릉')
car2 = Car('diesel', '전륜구동', '달달달달')
car3 = Car('hybrid', '4wd', '슈웅')

car1.drive()
print(car2.drive())

print('===')
car1.introduce()
car3.introduce()

print('===')
print(f'이 세상의 자동차는 {Car.wheels}개의 바퀴를 가집니다.')
Car.increase_wheels()
print(f'이 세상의 자동차는 {Car.wheels}개의 바퀴를 가집니다.')
Car.description()
```

- 오늘은 문제가 어렵다긴 보다 클래스라는 것을 이해하는 것이 제일 어려웠던 것 같다.
- 자바스크립트 공부를 할 때도 느꼈지만 객체지향을 배울때면 항상 어려웠던 것 같다.
- 하지만 이번에 수업을 열심히 듣고 곰곰히 생각해본 결과 문제를 해결하는데 큰 어려움은 없었다.
- 그래도 앞으로의 코딩을 위해 계속해서 익숙해질 필요가 있다고 생각한다.