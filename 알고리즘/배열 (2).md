### 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세어 작업을 하며, 선형 시간에 정렬하는 효율적인 알고리즘
- 제한사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운터들의 배열을 사용하기 때문이다.
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다
- 시간복잡도
    - O(n+k) : n은 리스트 길이, k는 정수의 최댓값

### Baby-gin Game

- 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
- 그리고, 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다.
- 6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라
- 정렬하고 for문을 돌아서 나오면 되지 않나?

### 완전 검색

- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.
- Brute-force 혹은 generate-and-test 기법이라고도 불리 운다.
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
- 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
- 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.

### 순열

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.
nPr
- 그리고 nPr은 다음과 같은 식이 성립한다.
nPr = n * (n-1) * (n-2) * … * (n-r+1)
- nPn = n!이라고 표기하며 Factorial이라 부른다.
n! = n * (n-1) * (n-2) * … * 2 * 1

### 탐욕(Greedy)알고리즘

- 탐욕 알고리즘은 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들은 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다.
1. 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해집합에 추가한다.
2. 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
3. 해 검사: 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1)의 해 선택부터 다시 시작한다.

### Baby-gin 해결

- counts를 활용해서 각 카드들의 개수를 세서 만약 개수가 있다면 triplet인지 확인 맞으면 3을 빼주고 다시 run인지 확인 만약 아니라면 run인지 확인 두개의 조건에 만족하지 않는다면 Baby-gin 아님
- 차례대로 인덱스들을 하나씩 확인


### 어려웠던 문제들
```python
T = int(input())

for tc in range(1, T+1):
    k, n, m = map(int, input().split())
    arr = list(map(int, input().split()))
    # k = 충전 없이 갈 수 있는 거리
    # n = 총 정류장 수
    # m = 충전 가능한 정류장 수
    # arr = 충전 가능한 정류장 배열
    current_pos = 0     # 현재 위치
    charge_count = 0    # 충전 횟수

    # 충전 가능한 정류장 배열 끝에 도착지를 추가 왜? 마지막 충전하고 갈 수 있는지 없는지 확인해야하니까
    arr += [n]

    for i in range(m + 1):
        # 만약 현재 위치에서 다음 충전소까지 거리가 k보다 크면
        if arr[i] - current_pos > k:    # 예를들어 첫 번째 예시에서 i가 2이면 5이므로 5 - 0 은 3보다 크므로 if문에 들어온다
            current_pos = arr[i - 1]    # 그러므로 충전은 그 전 arr[i-1]에서 해야하니 현재 위치를 arr[i-1]로 만든다
            charge_count += 1           # 충전은 했으므로 +1 해준다
            if arr[i] - current_pos > k:    # 만약 현재의 arr[i]에서 arr[i-1]에 해당하는 현재 위치를 뺏을때 k보다 크다면
                charge_count = 0        # 그것은 곧 거리가 더 멀기 때문에 충전을 하지 못하는 상태가 된다.
                break


    print(f'#{tc} {charge_count}')
```
- 왜 어려웠을까?
    - 사실 지금 보면 간단한 문제이다
    - 부족했던 것은 수학적으로 어떻게 식을 세울까를 못했던 것 같다.
    - 여기서 for문은 중요하지 않다. 구하고자 하는 것은 charge_count이기 때문이다.
    - 즉 for문이 몇 번 돌든 상관없이 if문에 해당하는 것만 잘 구현했다면 쉽게 풀 문제였다.
    - 나의 패착은 k값을 잘 활용하지 않은점
    - arr의 각index 길이가 k를 기준으로 해야겠다! 라는 것만 생각이 났으면 충분히 쉽게 풀만한 문제였다.
    - 결국 문제를 풀긴했지만 문제를 이해하는데 오래걸려서 아시웠다.