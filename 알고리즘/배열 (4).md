## 검색

### 순차검색

- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
    - 가장 간단하고 직관적인 검색 방법
    - 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
    - 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적임
- 검색 과정
    - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다
    - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
    - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패

### 정렬되어 있는 경우와 정렬되어 있지 않은 경우

- 정렬되어 있지 않은 경우(순차검색)
    - 첫 번째 원소를 찾을 때는 1번 비교, 두 번째 원소를 찾을 때는 2번 비교…
    - 정렬되지 않은 자료에서의 순차 검색의 평균 비교 회수
    - 시간복잡도 : O(n)
- 정렬되어 있을 경우(순차검색)
    - 자료가 오름차순으로 정렬된 상태에서 검색을 실시한다고 가정하자.
    - 자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료한다.

### 이진검색

- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    - 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
- 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.

### 선택정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
- 정렬 과정
    - 주어진 리스트 중에서 최소값을 찾는다.
    - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
    - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
- 시간복잡도
    - O(n^2)


### 어려웠던 문제
```python
for tc in range(1, 11):
    t = int(input())
    arr = [list(map(int, input().split())) for _ in range(100)]

    for col in range(100):
        if arr[0][col] == 1:
            i, j = 0, col   # 기존 col값을 유지하고 j에 새로 할당
            while i < 100:
                if i == 99 and arr[i][j] == 2:     # i = 99 일때 결과값이면 col값을 출력
                    print(f'#{t} {col}')
                if j + 1 < 100 and arr[i][j+1] == 1:    # 오른쪽에 1이 있으면 오른쪽으로 1이 안니올때까지 while문을 돌린다
                    while j + 1 < 100 and arr[i][j + 1] == 1:
                        j += 1
                elif j - 1 >= 0 and arr[i][j-1] == 1:      # 왼쪽에 1이 있으면 왼쪽으로 1이 안나올때까지 while문을 돌린다.
                    while j - 1 >= 0 and arr[i][j - 1] == 1:
                        j -= 1
                i += 1                                      # 두개의 좌우 방향에 안걸리면 i += 1을 해준다.

```

- 사다리게임을 알고리즘으로 구현한 문제였다.
- 사실 뒤에서(99번째 인덱스)부터 if문을 걸었을 때는 쉽게 올라왔다
- 하지만 앞에서(0번째 인덱스) 부터 갔을때 코드를 거의 갈아엎어야할 정도로 바꾸게 되었다.
- 왜냐하면 지금처럼 왼쪽 오른쪽 중에 1이 나왔을 때 while문을 돌리지 않고 해당 위치에 0을 넣어서 왔던 길로는 다시 못가게 구현했기 때문이였다.
- 그래서 while문을 통해서 1이 아닐때까지 왼쪽이나 오른쪽으로 가게 만들었다.
- 그리고 결과값을 뽑을 때도 `i == 99`와 `arr[i][j] == 2`를 둘다 넣어야 했고 `arr[i][j]`만 넣었을 때는 무한 루프에 빠지게 되었다. 
- 하지만 결국 코드를 더욱 간결하게 짤 수 있어서 좋았던 시도라고 생각한다.